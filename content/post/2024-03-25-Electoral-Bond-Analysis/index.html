---
title: "Data Cleaning with R using *PDFtools* and *stringr*"
author: "Dr. Ankit Deshmukh"
date: 2024-03-25
categories: ["Visulization", "R"]
tags: ["R", "Data Cleaning"]
cover:
    image: "Cover.png"
    alt: "Image of Data and Stringr logo"
---

<script src="{{< blogdown/postref >}}index_files/htmlwidgets/htmlwidgets.js"></script>
<link href="{{< blogdown/postref >}}index_files/datatables-css/datatables-crosstalk.css" rel="stylesheet" />
<script src="{{< blogdown/postref >}}index_files/datatables-binding/datatables.js"></script>
<script src="{{< blogdown/postref >}}index_files/jquery/jquery-3.6.0.min.js"></script>
<link href="{{< blogdown/postref >}}index_files/dt-core/css/jquery.dataTables.min.css" rel="stylesheet" />
<link href="{{< blogdown/postref >}}index_files/dt-core/css/jquery.dataTables.extra.css" rel="stylesheet" />
<script src="{{< blogdown/postref >}}index_files/dt-core/js/jquery.dataTables.min.js"></script>
<link href="{{< blogdown/postref >}}index_files/crosstalk/css/crosstalk.min.css" rel="stylesheet" />
<script src="{{< blogdown/postref >}}index_files/crosstalk/js/crosstalk.min.js"></script>


<p>SBI Submits all the data to ECI and ECI publish it on <code>Thursday 21 Mar 2024, 6:32 PM</code> Links of 2 files are provided here:</p>
<p><a href="https://www.eci.gov.in/disclosure-of-electoral-bonds">Disclosure of Electoral Bonds</a></p>
<ul>
<li><p><a href="https://www.eci.gov.in/eci-backend/public/api/download?url=LMAhAK6sOPBp%2FNFF0iRfXbEB1EVSLT41NNLRjYNJJP1KivrUxbfqkDatmHy12e%2FzBiU51zPFZI5qMtjV1qgjFmSC%2FSz9GPIId9Zlf4WX9G%2BbMQG4kb31sE0S7b31iev056VRYj06iIsFTelbq233Uw%3D%3D">Details of Electoral Bonds submitted by SBI on 21st March 2024 (EB_Redemption_Details)</a></p></li>
<li><p><a href="https://www.eci.gov.in/eci-backend/public/api/download?url=LMAhAK6sOPBp%2FNFF0iRfXbEB1EVSLT41NNLRjYNJJP1KivrUxbfqkDatmHy12e%2FzBiU51zPFZI5qMtjV1qgjFmSC%2FSz9GPIId9Zlf4WX9G%2FfwrEDQFGDuen%2FyU1C5gVqkKaRPDqHSBCdx74poKJJ7Q%3D%3D">Details of Electoral Bonds submitted by SBI on 21st March 2024 (EB_Purchase_Details)</a></p></li>
</ul>
<p>To know the background of the case read this: <a href="https://www.business-standard.com/india-news/submitted-details-of-electoral-bonds-including-unique-code-to-ec-sbi-124032100933_1.html">SBI submits all electoral bond details, including unique numbers, to ECI</a></p>
<div id="a-shrot-note-on-regexregex" class="section level3">
<h3>A shrot note on regex<code>regex</code></h3>
<p><strong>regex</strong>, short for Regular Expressions, are essentially sequences of characters that form a search pattern, which is then used to match strings or parts of strings in a text. Think of them as sophisticated search queries that allow you to find specific patterns within a larger body of text. regex can be used for simple patterns like a specific word or phrase, or you can create complex patterns to match more intricate structures such as email addresses, URLs, dates, and more.</p>
<p>For example, if you wanted to find all email addresses in a text document, you could use a regular expression pattern like <code>[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-.]+</code>. This pattern breaks down as follows:</p>
<pre class="r"><code># Sample emails
em1 &lt;- &quot;example-1_Random@gmail.com&quot; # this is a valid email
em2 &lt;- &quot;example*1_Random$gmail.com&quot; # this is an invalid email. 

# Detect email addresses
stringr::str_detect(c(em1, em2), &quot;[a-zA-Z0-9_.+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z0-9-.]+&quot;)
## [1]  TRUE FALSE
## [1]  TRUE FALSE</code></pre>
<p><strong>a-zA-Z0-9_.+-]+</strong> matches one or more alphanumeric characters, dots, underscores, percent signs, plus signs, or hyphens, representing the username portion of an email address.</p>
<p><span class="math inline">\(\textbf{@}\)</span> matches the “@” symbol, separating the username from the domain.</p>
<p><strong>[A-Za-z0-9.-]+</strong> matches one or more alphanumeric characters, dots, or hyphens, representing the domain name.</p>
<p><strong>\.</strong> matches a literal dot, separating the domain from the top-level domain.</p>
<p><strong>[a-zA-Z0-9-.]+</strong> matches two or more alphabetic characters, representing the top-level domain (e.g., com, org, net).</p>
<p>Regular expressions can be used in various programming languages, here we are using it with R programming with <code>stringr</code> package.</p>
</div>
<div id="required-r-libraries" class="section level3">
<h3>Required R libraries:</h3>
<pre class="r"><code># To process the PDF document 
if(!require(lubridate)){install.packages(&quot;lubridate&quot;);library(lubridate)}
if(!require(pdftools)){install.packages(&quot;pdftools&quot;);library(pdftools)}
if(!require(stringr)){install.packages(&quot;stringr&quot;);library(stringr)}
if(!require(readxl)){install.packages(&quot;readxl&quot;);library(readxl)}
#if(!require(xlsx)){install.packages(&quot;xlsx&quot;);library(xlsx)}
if(!require(DT)){install.packages(&quot;DT&quot;);library(DT)}</code></pre>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:unnamed-chunk-3"></span>
<img src="Images/Tree.png" alt="Structure of the files in working directory" width="524" />
<p class="caption">
Figure 1: Structure of the files in working directory
</p>
</div>
</div>
<div id="cleaning-the-party-data" class="section level2">
<h2>Cleaning the Party data</h2>
<p>We starting with reading the file <code>Parties.pdf</code> from <code>./Data/Raw Data/</code> directory. The regular expression [\r\n]+ is used to match one or more occurrences of either a carriage return ( or a newline character (). After that <code>str_trip</code> remove space either from starting or end of the each string. <code>str_split_fixed</code> split string with <code>"\\s{2,}"</code> means 2 consiqutive space till it reaches 9 element. We choose 9 because there are total 9 column in <code>Parties.pdf</code>.</p>
<pre class="r"><code>Party &lt;- pdf_text(&quot;./Data/Raw Data/Parties.pdf&quot;)
Party &lt;- unlist(str_split(Party, &quot;[\\r\\n]+&quot;))
Party &lt;- as.data.frame(str_split_fixed(str_trim(Party), &quot;\\s{2,}&quot;, n = 9))

head(Party,5)
##           V1                                                   V2          V3
## 1    Date of                                       Account no. of        Bond
## 2     Sr No.                          Name of the Political Party      Prefix
## 3 Encashment                                      Political Party      Number
## 4          1 12/Apr/2019 ALL INDIA ANNA DRAVIDA MUNNETRA KAZHAGAM *******5199
## 5          2 12/Apr/2019 ALL INDIA ANNA DRAVIDA MUNNETRA KAZHAGAM *******5199
##              V4         V5          V6    V7      V8 V9
## 1    Pay Branch                                        
## 2 Denominations Pay Teller                             
## 3          Code                                        
## 4            OC        775 1,00,00,000 00800 2770121   
## 5            OC       3975 1,00,00,000 00800 2770121</code></pre>
<p>Upon inspection we find all the pages of pdf as the table header and now we are removing the headers, I remove row containing “Date of”, “Sr No.”, “Encashment” using V1 column.</p>
<p>After that we have Page.and it’s numbers for each pages read by pdftools. We remove using <code>str_extract</code>, here Page{dash} represent anything after Page must be selected. We also remove rows that have all the columns emptly.</p>
<pre class="r"><code>Index = Party$V1 %in% c(&quot;Date of&quot;, &quot;Sr No.&quot;, &quot;Encashment&quot;)
Party &lt;- Party[!Index,]

Index2 = is.na(str_extract(Party$V1, &quot;Page.&quot;))
Party &lt;- Party[Index2,];
Party &lt;- Party[!apply(Party == &quot;&quot;, 1, all),]

rm(Index, Index2)</code></pre>
<p>Now, all the data is stored in the <code>Party</code> variable the structure of it.</p>
<pre class="r"><code>class(Party)
## [1] &quot;data.frame&quot;
dim(Party)
## [1] 20421     9</code></pre>
<p>We found at some row total number of columns are greater then 9. So before constructing the final data frame we choose checking each row with <code>for</code> loop. We pre-poulated several columns such as <code>SN</code>, <code>Date of Enchashment</code></p>
<pre class="r"><code>n = rep(NA,dim(Party)[1])

Index_m &lt;- !nchar(Party$V9)&gt;0
Col1 = as.data.frame(str_split_fixed(Party$V2, pattern = &quot; &quot;, n = 2))

Party_Data &lt;- data.frame(&quot;SN&quot; = as.numeric(Party$V1),
                         &quot;Date of Encashment&quot; = lubridate::dmy(Col1$V1),
                         &quot;Party Name&quot; = n,
                         &quot;Account No&quot; = n,
                         &quot;Prefix&quot; = n,
                         &quot;Bond No&quot; = n,
                         &quot;Denominations&quot; = n,
                         &quot;Pay Branch Code&quot; = n,
                         &quot;Pay Teller&quot; = n)
col7_t &lt;- as.numeric(gsub(&quot;,&quot;, &quot;&quot;, Party$V6))
col7_f &lt;- as.numeric(gsub(&quot;,&quot;, &quot;&quot;, Party$V7))


for(ii in seq_along(n)){
    if (Index_m[ii]) {
        Party_Data[ii,3] &lt;- Col1$V2[ii]
        Party_Data[ii,4] &lt;- Party$V3[ii]
        Party_Data[ii,5] &lt;- Party$V4[ii]
        Party_Data[ii,6] &lt;- as.numeric(Party$V5)[ii]
        Party_Data[ii,7] &lt;- col7_t[ii]
        Party_Data[ii,8] &lt;- Party$V7[ii]
        Party_Data[ii,9] &lt;- as.numeric(Party$V8)[ii]
    } else {
        Party_Data[ii,3] &lt;- Party$V3[ii]
        Party_Data[ii,4] &lt;- Party$V4[ii]
        Party_Data[ii,5] &lt;- Party$V5[ii]
        Party_Data[ii,6] &lt;- as.numeric(Party$V6)[ii]
        Party_Data[ii,7] &lt;- col7_f[ii]
        Party_Data[ii,8] &lt;- Party$V8[ii]
        Party_Data[ii,9] &lt;- as.numeric(Party$V9)[ii]
    }
    # print(ii) # running this might take some time. 
    # IMP: don&#39;t run white building the site.
}</code></pre>
<p>Now, we have table similar to pdf, but I want to create unique id <code>un_id</code> by merging Perfiex with Bond No., so that I can match Parties to Donner, after that I save the data into <code>Party_Cleaned.xlsx</code> file.</p>
<pre class="r"><code>un_id= paste0(Party_Data$Prefix,
              str_pad(Party_Data$Bond.No, width = 5,pad = &quot;0&quot;))
Party_Data$unique_ID &lt;- un_id
write.xlsx(Party_Data, file=&quot;./Data/Processed xlsx/Party_Cleaned.xlsx&quot;, row.names = FALSE)</code></pre>
<p>Now to time to generate some table data, I am aggregation Party and Denominations data for table. To aggregate the data with Party name <code>aggregate</code> function from base R is used. After that <code>DT::datatable</code> is used for interactive table.</p>
<pre class="r"><code>
Party_Data &lt;- read_xlsx(path = &quot;./Data/Processed xlsx/Party_Cleaned.xlsx&quot;)

fx_name &lt;- function(x) {c(length(x), median(x), round(mean(x),0), sum(x))}
agg_data = aggregate(Party_Data, Denominations ~ Party.Name, FUN = fx_name)

agg_data_df &lt;- data.frame(&quot;Purchaser&quot; = agg_data$Party.Name,
                          &quot;Count&quot; = agg_data$Denominations[,1],
                          &quot;Median&quot; = agg_data$Denominations[,2],
                          &quot;Mean&quot; = agg_data$Denominations[,3],
                          &quot;Sum&quot; = agg_data$Denominations[,4])

datatable(agg_data_df, options = list(
    initComplete = JS(
        &quot;function(settings, json) {&quot;,
        &quot;$(this.api().table().header()).css({&#39;background-color&#39;: &#39;#fff&#39;, &#39;color&#39;: &#39;#111&#39;});&quot;,
        &quot;$(this.api().table().container()).css({&#39;background-color&#39;: &#39;#fff&#39;, &#39;color&#39;: &#39;#111&#39;});&quot;,
        &quot;$(this.api().table().body()).css({&#39;background-color&#39;: &#39;#fff&#39;, &#39;color&#39;: &#39;#111&#39;});&quot;,
        &quot;}&quot;)))%&gt;% formatCurrency(c(&#39;Median&#39;, &#39;Mean&#39;, &#39;Sum&#39;),
                                          currency = &quot;₹&quot;,
                                          interval = 3,
                                          mark = &quot;,&quot;,
                                          digits = 0)</code></pre>
<div class="datatables html-widget html-fill-item" id="htmlwidget-1" style="width:100%;height:auto;"></div>
<script type="application/json" data-for="htmlwidget-1">{"x":{"filter":"none","vertical":false,"data":[["1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18","19","20","21","22","23","24"],["AAM AADMI PARTY","ADYAKSHA SAMAJVADI PARTY","ALL INDIA ANNA DRAVIDA MUNNETRA KAZHAGAM","ALL INDIA TRINAMOOL CONGRESS","BHARAT RASHTRA SAMITHI","BHARATIYA JANATA PARTY","BIHAR PRADESH JANTA DAL(UNITED)","BIJU JANATA DAL","DRAVIDA MUNNETRA KAZHAGAM (DMK)","GOA FORWARD PARTY","JAMMU AND KASHMIR NATIONAL CONFERENCE","JANASENA PARTY","JANATA DAL ( SECULAR )","JHARKHAND MUKTI MORCHA","MAHARASHTRAWADI GOMNTAK PARTY","NATIONALIST CONGRESS PARTY MAHARASHTRA PRADESH","PRESIDENT, ALL INDIA CONGRESS COMMITTEE","RASHTRIYA JANTA DAL","SHIROMANI AKALI DAL","SHIVSENA","SIKKIM DEMOCRATIC FRONT","SIKKIM KRANTIKARI MORCHA","TELUGU DESAM PARTY","YSR CONGRESS PARTY (YUVAJANA SRAMIKA RYTHU CONGRESS PARTY)"],[245,46,38,3305,1806,8633,14,861,648,17,5,39,75,45,28,121,3146,150,33,355,10,50,279,472],[1000000,100000,1000000,1000000,10000000,10000000,10000000,10000000,10000000,100000,1000000,1000000,10000000,1000000,100000,1000000,1000000,1000000,1000000,1000000,5500000,10000000,10000000,10000000],[2671429,3054348,1592105,4869989,6725968,7020168,10000000,9006969,9861111,205882,1000000,5384615,5800000,3000000,196429,2561983,4519598,4900000,2200000,4489617,5500000,7300000,7845161,7139831],[654500000,140500000,60500000,16095314000,12147099000,60605111000,140000000,7755000000,6390000000,3500000,5000000,210000000,435000000,135000000,5500000,310000000,14218655000,735000000,72600000,1593814000,55000000,365000000,2188800000,3370000000]],"container":"<table class=\"display\">\n  <thead>\n    <tr>\n      <th> <\/th>\n      <th>Purchaser<\/th>\n      <th>Count<\/th>\n      <th>Median<\/th>\n      <th>Mean<\/th>\n      <th>Sum<\/th>\n    <\/tr>\n  <\/thead>\n<\/table>","options":{"initComplete":"function(settings, json) {\n$(this.api().table().header()).css({'background-color': '#fff', 'color': '#111'});\n$(this.api().table().container()).css({'background-color': '#fff', 'color': '#111'});\n$(this.api().table().body()).css({'background-color': '#fff', 'color': '#111'});\n}","columnDefs":[{"targets":3,"render":"function(data, type, row, meta) {\n    return type !== 'display' ? data : DTWidget.formatCurrency(data, \"₹\", 0, 3, \",\", \".\", true, null);\n  }"},{"targets":4,"render":"function(data, type, row, meta) {\n    return type !== 'display' ? data : DTWidget.formatCurrency(data, \"₹\", 0, 3, \",\", \".\", true, null);\n  }"},{"targets":5,"render":"function(data, type, row, meta) {\n    return type !== 'display' ? data : DTWidget.formatCurrency(data, \"₹\", 0, 3, \",\", \".\", true, null);\n  }"},{"className":"dt-right","targets":[2,3,4,5]},{"orderable":false,"targets":0},{"name":" ","targets":0},{"name":"Purchaser","targets":1},{"name":"Count","targets":2},{"name":"Median","targets":3},{"name":"Mean","targets":4},{"name":"Sum","targets":5}],"order":[],"autoWidth":false,"orderClasses":false}},"evals":["options.initComplete","options.columnDefs.0.render","options.columnDefs.1.render","options.columnDefs.2.render"],"jsHooks":[]}</script>
</div>
<div id="cleaning-the-doners-data" class="section level2">
<h2>Cleaning the Doners data</h2>
<p>Similar to the Party data, explore the donners data from the pdf “Company.pdf” in the folder <code>Data/Raw Data</code>. Similar processing methodology is use as Party.pdf with one change this time total number of columns are 12.</p>
<pre class="r"><code>Comp &lt;- pdf_text(&quot;./Data/Raw Data/Company.pdf&quot;)
Comp &lt;- unlist(str_split(Comp, &quot;[\\r\\n]+&quot;))
Comp &lt;- str_trim(gsub(&quot;,&quot;,&quot;&quot;,Comp))
</code></pre>
<p>Based on the data format, I found breaking it from as digit followed by space <code>(?&lt;=\\d )</code> is more useful.</p>
<pre class="r"><code>Comp = as.data.frame(str_split_fixed(Comp, &quot;(?&lt;=\\d )&quot;, n = 12))</code></pre>
<p>Now processing the first column which has the structure of</p>
<pre class="r"><code>Comp$V1[1:4]</code></pre>
<p>This will break the string the string in 2 columns, “SN”, and “Reference No URN”</p>
<pre class="r"><code>a &lt;- gsub(&quot;\\s+&quot;, &quot; &quot;, Comp$V1, perl = TRUE)

Index = a %in% c(a[1:3])
Comp &lt;- Comp[!Index,]

Index2 = is.na(str_extract(Comp$V1, &quot;Page.&quot;))
Comp &lt;- Comp[Index2,]
Comp &lt;- Comp[!apply(Comp == &quot;&quot;, 1, all),]

rm(Index, Index2,a,b,c)

BondN &lt;- as.numeric(str_sub(str_trim(Comp$V6), -6,-1))

# you cans simply choose last 4 disit of the V6
c = str_trim(str_sub(str_trim(Comp$V6),1,-6))
Name &lt;- str_trim(str_sub(c,1,-3))
Prefix &lt;- str_sub(c, -2, -1)

Comp_Data &lt;- data.frame(&quot;SN&quot; = as.numeric(Comp$V1),
                        &quot;Reference No URN&quot; = str_trim(Comp$V2),
                        &quot;Journal Date&quot; = dmy(Comp$V3),
                        &quot;Date of Purchase&quot; = dmy(Comp$V4),
                        &quot;Date of Expiry&quot; = dmy(Comp$V5),
                        &quot;Purchaser&quot; = Name,
                        &quot;Prefix&quot; = Prefix,
                        &quot;Bond No&quot; = BondN,
                        &quot;Denominations&quot; = as.numeric(str_trim(Comp$V7)),
                        &quot;Issue Branch Code&quot; = str_trim(Comp$V8),
                        &quot;Issue Teller&quot; = as.numeric(str_trim(Comp$V9)),
                        &quot;Status&quot; = str_trim(Comp$V10))

write.xlsx(Comp_Data, file=&quot;Comp_Cleaned.xlsx&quot;, row.names = FALSE)

# For L7
Index = Comp_Data$Reference.No.URN %in% c(&quot;00300202310100000003344&quot;,
                                          &quot;00300202310120000003422&quot;,
                                          &quot;00300202310130000003470&quot;)
Comp_Data$Purchaser[Index] &lt;- &quot;L7 HITECH PRIVATE LIMITED&quot;
Comp_Data$Denominations[Index] &lt;- 10000000
Comp_Data$Issue.Branch.Code[Index] &lt;- &quot;00300&quot;
Comp_Data$Prefix[Index] &lt;- &quot;OC&quot;
Comp_Data$Status[Index] &lt;- &quot;Paid&quot;
Comp_Data$Issue.Teller[Index] &lt;- 1022034 # same value is used as it&#39;s not much useful information

## Adding Bond no. for all 3 cases
Comp_Data$Bond.No[Index] &lt;- c(16524, 16531, 16521, 16535, 16529, 16527, 16523, 16519, 16533, 16569, 16577, 16565, 16567,16573, 16563, 16571, 16575, 16636,16638, 16644, 16642, 16640)
write.xlsx(Comp_Data, file=&quot;Comp_Cleaned.xlsx&quot;, row.names = FALSE)

print(paste0(&quot;No of NAs: &quot;, sum(is.na(Comp_Data))))
## Upon inspection  row have incorrect information, it&#39;s because the parser
#Cleaning it manually

# NOTE: NA values are cleaned manually and renamed it to &quot;Comp_Cleaned_Man.xlsx&quot;

if(!require(readxl)){install.packages(&quot;readxl&quot;);library(readxl)}
Comp_Data &lt;- read_xlsx(path = &quot;Comp_Cleaned_man.xlsx&quot;, sheet = &quot;Sheet1&quot;)
fx_name &lt;- function(x) {c(length(x), median(x), round(mean(x),0), sum(x))}
agg_data = aggregate(Comp_Data, Denominations ~ Purchaser, FUN = fx_name)

agg_data_df &lt;- data.frame(&quot;Purchaser&quot; = agg_data$Purchaser,
                          &quot;Count&quot; = agg_data$Denominations[,1],
                          &quot;Median&quot; = agg_data$Denominations[,2],
                          &quot;Mean&quot; = agg_data$Denominations[,3],
                          &quot;Sum&quot; = agg_data$Denominations[,4])

datatable(agg_data_df, options = list(
    initComplete = JS(
        &quot;function(settings, json) {&quot;,
        &quot;$(this.api().table().header()).css({&#39;background-color&#39;: &#39;#fff&#39;, &#39;color&#39;: &#39;#111&#39;});&quot;,
        &quot;$(this.api().table().container()).css({&#39;background-color&#39;: &#39;#fff&#39;, &#39;color&#39;: &#39;#111&#39;});&quot;,
        &quot;$(this.api().table().body()).css({&#39;background-color&#39;: &#39;#fff&#39;, &#39;color&#39;: &#39;#111&#39;});&quot;,
        &quot;}&quot;)))%&gt;% formatCurrency(c(&#39;Median&#39;, &#39;Mean&#39;, &#39;Sum&#39;),
                                          currency = &quot;₹&quot;,
                                          interval = 3,
                                          mark = &quot;,&quot;,
                                          digits = 0)</code></pre>
</div>
<div id="processing-the-pdf-in-an-easy-way" class="section level2">
<h2>Processing the pdf in an easy way:</h2>
<p>Using <code>tabulizer</code> can extract pdf tables, I find it’s show but works simple table data.</p>
<pre class="r"><code># remotes::install_github(c(&quot;ropensci/tabulizerjars&quot;, &quot;ropensci/tabulizer&quot;))
library(tabulizer)

out_tables &lt;- extract_tables(&quot;./2024-03-25-Electoral-Bond-Analysis/Data/Raw Data/Company.pdf&quot;)

Out &lt;- out_tables[[1]]

for (ii in 2:length(out_tables)) {
    temp &lt;- out_tables[[ii]]
    temp1 &lt;- temp[2:dim(temp)[1],] 
    Out &lt;- rbind(Out,temp1)
}</code></pre>
</div>
<div id="insights-from-the-data" class="section level2">
<h2>Insights from the data</h2>
</div>
